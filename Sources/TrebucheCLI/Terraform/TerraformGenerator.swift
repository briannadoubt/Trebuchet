import Foundation

/// Generates Terraform configuration for AWS deployment
public struct TerraformGenerator {
    private let fileManager: FileManager

    public init(fileManager: FileManager = .default) {
        self.fileManager = fileManager
    }

    /// Generate Terraform files for deployment
    /// - Parameters:
    ///   - config: Resolved configuration
    ///   - actors: Discovered actor metadata
    ///   - outputDir: Directory to write Terraform files
    /// - Returns: Path to the generated Terraform directory
    public func generate(
        config: ResolvedConfig,
        actors: [ActorMetadata],
        outputDir: String
    ) throws -> String {
        // Create output directory
        try fileManager.createDirectory(atPath: outputDir, withIntermediateDirectories: true)

        // Generate main.tf
        let mainTf = generateMain(config: config, actors: actors)
        try mainTf.write(toFile: "\(outputDir)/main.tf", atomically: true, encoding: .utf8)

        // Generate variables.tf
        let variablesTf = generateVariables(config: config)
        try variablesTf.write(toFile: "\(outputDir)/variables.tf", atomically: true, encoding: .utf8)

        // Generate outputs.tf
        let outputsTf = generateOutputs(config: config)
        try outputsTf.write(toFile: "\(outputDir)/outputs.tf", atomically: true, encoding: .utf8)

        // Generate terraform.tfvars template
        let tfvars = generateTfvars(config: config)
        try tfvars.write(toFile: "\(outputDir)/terraform.tfvars.example", atomically: true, encoding: .utf8)

        return outputDir
    }

    // MARK: - Main Configuration

    private func generateMain(config: ResolvedConfig, actors: [ActorMetadata]) -> String {
        let sanitizedName = config.projectName.replacingOccurrences(of: "-", with: "_")

        return """
        # ============================================================================
        # Trebuche AWS Infrastructure
        # Project: \(config.projectName)
        # Generated by trebuche CLI
        # ============================================================================

        terraform {
          required_version = ">= 1.0"

          required_providers {
            aws = {
              source  = "hashicorp/aws"
              version = "~> 5.0"
            }
          }
        }

        provider "aws" {
          region = var.aws_region

          default_tags {
            tags = {
              Project   = "\(config.projectName)"
              ManagedBy = "trebuche"
            }
          }
        }

        # ============================================================================
        # Data Sources
        # ============================================================================

        data "aws_caller_identity" "current" {}
        data "aws_region" "current" {}

        # ============================================================================
        # IAM Role for Lambda
        # ============================================================================

        resource "aws_iam_role" "lambda_role" {
          name = "\(sanitizedName)_lambda_role"

          assume_role_policy = jsonencode({
            Version = "2012-10-17"
            Statement = [
              {
                Action = "sts:AssumeRole"
                Effect = "Allow"
                Principal = {
                  Service = "lambda.amazonaws.com"
                }
              }
            ]
          })
        }

        resource "aws_iam_role_policy_attachment" "lambda_basic" {
          role       = aws_iam_role.lambda_role.name
          policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        }

        resource "aws_iam_role_policy" "lambda_policy" {
          name = "\(sanitizedName)_lambda_policy"
          role = aws_iam_role.lambda_role.id

          policy = jsonencode({
            Version = "2012-10-17"
            Statement = [
              {
                Effect = "Allow"
                Action = [
                  "dynamodb:GetItem",
                  "dynamodb:PutItem",
                  "dynamodb:UpdateItem",
                  "dynamodb:DeleteItem",
                  "dynamodb:Query",
                  "dynamodb:Scan"
                ]
                Resource = [
                  aws_dynamodb_table.actor_state.arn,
                  "${aws_dynamodb_table.actor_state.arn}/index/*"
                ]
              },
              {
                Effect = "Allow"
                Action = [
                  "servicediscovery:RegisterInstance",
                  "servicediscovery:DeregisterInstance",
                  "servicediscovery:DiscoverInstances",
                  "servicediscovery:GetInstance",
                  "servicediscovery:ListInstances"
                ]
                Resource = "*"
              },
              {
                Effect = "Allow"
                Action = [
                  "lambda:InvokeFunction"
                ]
                Resource = aws_lambda_function.actors.arn
              }
            ]
          })
        }

        # ============================================================================
        # DynamoDB Table for Actor State
        # ============================================================================

        resource "aws_dynamodb_table" "actor_state" {
          name           = "\(config.stateTableName)"
          billing_mode   = "PAY_PER_REQUEST"
          hash_key       = "actorId"

          attribute {
            name = "actorId"
            type = "S"
          }

          ttl {
            attribute_name = "ttl"
            enabled        = true
          }

          tags = {
            Name = "\(config.projectName)-actor-state"
          }
        }

        # ============================================================================
        # CloudMap Namespace and Service
        # ============================================================================

        resource "aws_service_discovery_private_dns_namespace" "actors" {
          name        = "\(config.discoveryNamespace).local"
          description = "Namespace for \(config.projectName) actors"
          vpc         = var.vpc_id
        }

        resource "aws_service_discovery_service" "actors" {
          name = "actors"

          dns_config {
            namespace_id = aws_service_discovery_private_dns_namespace.actors.id

            dns_records {
              ttl  = 10
              type = "A"
            }

            routing_policy = "MULTIVALUE"
          }

          health_check_custom_config {
            failure_threshold = 1
          }
        }

        # ============================================================================
        # Lambda Function
        # ============================================================================

        resource "aws_lambda_function" "actors" {
          function_name = "\(sanitizedName)_actors"
          role          = aws_iam_role.lambda_role.arn

          filename         = var.lambda_package_path
          source_code_hash = filebase64sha256(var.lambda_package_path)

          handler = "bootstrap"
          runtime = "provided.al2023"

          architectures = ["arm64"]

          memory_size = var.lambda_memory
          timeout     = var.lambda_timeout

          environment {
            variables = {
              STATE_TABLE = aws_dynamodb_table.actor_state.name
              NAMESPACE   = aws_service_discovery_private_dns_namespace.actors.name
              AWS_REGION  = var.aws_region
              LOG_LEVEL   = var.log_level
        \(generateActorEnvVars(actors: actors))
            }
          }

          vpc_config {
            subnet_ids         = var.subnet_ids
            security_group_ids = var.security_group_ids
          }

          tags = {
            Name = "\(config.projectName)-actors"
          }
        }

        # ============================================================================
        # Lambda Function URL (Alternative to API Gateway)
        # ============================================================================

        resource "aws_lambda_function_url" "actors" {
          function_name      = aws_lambda_function.actors.function_name
          authorization_type = var.lambda_url_auth_type

          cors {
            allow_credentials = true
            allow_headers     = ["*"]
            allow_methods     = ["POST", "GET"]
            allow_origins     = var.cors_allowed_origins
            max_age           = 86400
          }
        }

        # ============================================================================
        # API Gateway (Optional, more features than Function URL)
        # ============================================================================

        resource "aws_apigatewayv2_api" "actors" {
          count = var.create_api_gateway ? 1 : 0

          name          = "\(sanitizedName)-api"
          protocol_type = "HTTP"

          cors_configuration {
            allow_headers = ["*"]
            allow_methods = ["POST", "GET", "OPTIONS"]
            allow_origins = var.cors_allowed_origins
            max_age       = 86400
          }
        }

        resource "aws_apigatewayv2_integration" "actors" {
          count = var.create_api_gateway ? 1 : 0

          api_id             = aws_apigatewayv2_api.actors[0].id
          integration_type   = "AWS_PROXY"
          integration_uri    = aws_lambda_function.actors.invoke_arn
          integration_method = "POST"
          payload_format_version = "2.0"
        }

        resource "aws_apigatewayv2_route" "invoke" {
          count = var.create_api_gateway ? 1 : 0

          api_id    = aws_apigatewayv2_api.actors[0].id
          route_key = "POST /invoke"
          target    = "integrations/${aws_apigatewayv2_integration.actors[0].id}"
        }

        resource "aws_apigatewayv2_route" "health" {
          count = var.create_api_gateway ? 1 : 0

          api_id    = aws_apigatewayv2_api.actors[0].id
          route_key = "GET /health"
          target    = "integrations/${aws_apigatewayv2_integration.actors[0].id}"
        }

        resource "aws_apigatewayv2_stage" "default" {
          count = var.create_api_gateway ? 1 : 0

          api_id      = aws_apigatewayv2_api.actors[0].id
          name        = "$default"
          auto_deploy = true
        }

        resource "aws_lambda_permission" "api_gateway" {
          count = var.create_api_gateway ? 1 : 0

          statement_id  = "AllowAPIGateway"
          action        = "lambda:InvokeFunction"
          function_name = aws_lambda_function.actors.function_name
          principal     = "apigateway.amazonaws.com"
          source_arn    = "${aws_apigatewayv2_api.actors[0].execution_arn}/*/*"
        }

        # ============================================================================
        # CloudWatch Log Group
        # ============================================================================

        resource "aws_cloudwatch_log_group" "lambda" {
          name              = "/aws/lambda/${aws_lambda_function.actors.function_name}"
          retention_in_days = var.log_retention_days
        }
        """
    }

    private func generateActorEnvVars(actors: [ActorMetadata]) -> String {
        var lines: [String] = []

        for actor in actors.filter({ !$0.environment.isEmpty }) where actor.annotations.count > 0 {
            for (key, value) in actor.annotations where key.hasPrefix("env_") {
                let envKey = String(key.dropFirst(4)).uppercased()
                lines.append("      \(envKey) = \"\(value)\"")
            }
        }

        return lines.joined(separator: "\n")
    }

    // MARK: - Variables

    private func generateVariables(config: ResolvedConfig) -> String {
        let maxMemory = config.actors.map { $0.memory }.max() ?? 512
        let maxTimeout = config.actors.map { $0.timeout }.max() ?? 30

        return """
        # ============================================================================
        # Variables for \(config.projectName)
        # ============================================================================

        variable "aws_region" {
          description = "AWS region for deployment"
          type        = string
          default     = "\(config.region)"
        }

        variable "vpc_id" {
          description = "VPC ID for Lambda and CloudMap"
          type        = string
        }

        variable "subnet_ids" {
          description = "Subnet IDs for Lambda"
          type        = list(string)
        }

        variable "security_group_ids" {
          description = "Security group IDs for Lambda"
          type        = list(string)
        }

        variable "lambda_package_path" {
          description = "Path to the Lambda deployment package"
          type        = string
          default     = "../build/lambda-package.zip"
        }

        variable "lambda_memory" {
          description = "Lambda memory allocation in MB"
          type        = number
          default     = \(maxMemory)
        }

        variable "lambda_timeout" {
          description = "Lambda timeout in seconds"
          type        = number
          default     = \(maxTimeout)
        }

        variable "lambda_url_auth_type" {
          description = "Authorization type for Lambda URL (NONE or AWS_IAM)"
          type        = string
          default     = "NONE"
        }

        variable "create_api_gateway" {
          description = "Whether to create API Gateway (in addition to Lambda URL)"
          type        = bool
          default     = false
        }

        variable "cors_allowed_origins" {
          description = "Allowed origins for CORS"
          type        = list(string)
          default     = ["*"]
        }

        variable "log_level" {
          description = "Log level for the application"
          type        = string
          default     = "info"
        }

        variable "log_retention_days" {
          description = "CloudWatch log retention in days"
          type        = number
          default     = 14
        }
        """
    }

    // MARK: - Outputs

    private func generateOutputs(config: ResolvedConfig) -> String {
        """
        # ============================================================================
        # Outputs for \(config.projectName)
        # ============================================================================

        output "lambda_arn" {
          description = "ARN of the Lambda function"
          value       = aws_lambda_function.actors.arn
        }

        output "lambda_function_url" {
          description = "URL for invoking the Lambda function directly"
          value       = aws_lambda_function_url.actors.function_url
        }

        output "api_gateway_url" {
          description = "API Gateway endpoint URL"
          value       = var.create_api_gateway ? aws_apigatewayv2_api.actors[0].api_endpoint : null
        }

        output "dynamodb_table" {
          description = "DynamoDB table name for actor state"
          value       = aws_dynamodb_table.actor_state.name
        }

        output "cloudmap_namespace" {
          description = "CloudMap namespace for actor discovery"
          value       = aws_service_discovery_private_dns_namespace.actors.name
        }

        output "cloudmap_service_arn" {
          description = "CloudMap service ARN"
          value       = aws_service_discovery_service.actors.arn
        }
        """
    }

    // MARK: - Tfvars

    private func generateTfvars(config: ResolvedConfig) -> String {
        """
        # ============================================================================
        # Terraform Variables for \(config.projectName)
        # Copy this file to terraform.tfvars and fill in your values
        # ============================================================================

        aws_region = "\(config.region)"

        # VPC Configuration (required)
        vpc_id             = "vpc-xxxxxxxxx"
        subnet_ids         = ["subnet-xxxxxxxxx", "subnet-yyyyyyyyy"]
        security_group_ids = ["sg-xxxxxxxxx"]

        # Lambda Configuration
        lambda_memory  = \(config.actors.map { $0.memory }.max() ?? 512)
        lambda_timeout = \(config.actors.map { $0.timeout }.max() ?? 30)

        # API Gateway (optional - Lambda URL is created by default)
        create_api_gateway = false

        # CORS
        cors_allowed_origins = ["*"]

        # Logging
        log_level          = "info"
        log_retention_days = 14
        """
    }
}

extension ActorMetadata {
    var environment: [String: String] {
        annotations.filter { $0.key.hasPrefix("env_") }
    }
}
