import Foundation

/// Generates a server package from discovered actors
struct ServerGenerator {
    let terminal: Terminal

    init(terminal: Terminal = Terminal()) {
        self.terminal = terminal
    }

    /// Generate server package
    /// - Parameters:
    ///   - config: Trebuche configuration
    ///   - actors: Discovered actor metadata
    ///   - projectPath: Path to the main project
    ///   - outputPath: Where to generate the server package
    ///   - verbose: Enable verbose output
    func generate(
        config: TrebucheConfig,
        actors: [ActorMetadata],
        projectPath: String,
        outputPath: String,
        verbose: Bool
    ) throws {
        // Create output directory
        try FileManager.default.createDirectory(
            atPath: outputPath,
            withIntermediateDirectories: true
        )

        // Get project name (try to detect from Package.swift)
        let projectName = try detectProjectName(at: projectPath) ?? config.name

        // Generate Package.swift
        terminal.print("  Generating Package.swift...", style: .dim)
        let packageSwift = generatePackageSwift(
            projectName: projectName,
            projectPath: projectPath,
            config: config
        )
        try packageSwift.write(
            toFile: "\(outputPath)/Package.swift",
            atomically: true,
            encoding: .utf8
        )

        // Generate main.swift
        terminal.print("  Generating main.swift...", style: .dim)
        let mainSwift = generateMainSwift(
            actors: actors,
            projectName: projectName,
            config: config
        )

        let sourcesDir = "\(outputPath)/Sources/TrebucheAutoServer"
        try FileManager.default.createDirectory(
            atPath: sourcesDir,
            withIntermediateDirectories: true
        )
        try mainSwift.write(
            toFile: "\(sourcesDir)/main.swift",
            atomically: true,
            encoding: .utf8
        )

        // Generate .gitignore
        terminal.print("  Generating .gitignore...", style: .dim)
        let gitignore = """
        .build
        .swiftpm
        .DS_Store

        """
        try gitignore.write(
            toFile: "\(outputPath)/.gitignore",
            atomically: true,
            encoding: .utf8
        )

        // Generate README
        terminal.print("  Generating README.md...", style: .dim)
        let readme = generateREADME(projectName: projectName, actors: actors)
        try readme.write(
            toFile: "\(outputPath)/README.md",
            atomically: true,
            encoding: .utf8
        )
    }

    // MARK: - Private Helpers

    private func detectProjectName(at path: String) throws -> String? {
        let packagePath = "\(path)/Package.swift"
        guard FileManager.default.fileExists(atPath: packagePath) else {
            return nil
        }

        let packageContent = try String(contentsOfFile: packagePath, encoding: .utf8)

        // Simple regex to find: name: "ProjectName"
        let pattern = #"name:\s*"([^"]+)""#
        guard let regex = try? NSRegularExpression(pattern: pattern),
              let match = regex.firstMatch(
                in: packageContent,
                range: NSRange(packageContent.startIndex..., in: packageContent)
              ),
              let nameRange = Range(match.range(at: 1), in: packageContent) else {
            return nil
        }

        return String(packageContent[nameRange])
    }

    private func generatePackageSwift(
        projectName: String,
        projectPath: String,
        config: TrebucheConfig
    ) -> String {
        // Determine if we need PostgreSQL
        let needsPostgreSQL = config.state?.type == "postgresql" || config.state?.type == "postgres"

        var dependencies = """
            .package(path: "\(projectPath)"),
            .package(url: "https://github.com/briannadoubt/Trebuche.git", branch: "main")
        """

        if needsPostgreSQL {
            dependencies += """
        ,
            .package(url: "https://github.com/vapor/postgres-nio.git", from: "1.0.0")
        """
        }

        var targetDependencies = """
                "Trebuche",
                .product(name: "\(projectName)", package: "\(projectName)")
        """

        if needsPostgreSQL {
            targetDependencies += """
        ,
                .product(name: "TrebuchePostgreSQL", package: "Trebuche")
        """
        }

        return """
        // swift-tools-version: 6.0
        // Auto-generated by trebuche CLI
        // DO NOT EDIT - Regenerate with: trebuche generate server --force

        import PackageDescription

        let package = Package(
            name: "TrebucheAutoServer",
            platforms: [.macOS(.v14)],
            dependencies: [
        \(dependencies)
            ],
            targets: [
                .executableTarget(
                    name: "TrebucheAutoServer",
                    dependencies: [
        \(targetDependencies)
                    ]
                )
            ]
        )

        """
    }

    private func generateMainSwift(
        actors: [ActorMetadata],
        projectName: String,
        config: TrebucheConfig
    ) -> String {
        let needsPostgreSQL = config.state?.type == "postgresql" || config.state?.type == "postgres"

        var imports = """
        // Auto-generated by trebuche CLI
        // DO NOT EDIT - Regenerate with: trebuche generate server --force

        import Trebuche
        import \(projectName)
        import Foundation
        """

        if needsPostgreSQL {
            imports += "\nimport TrebuchePostgreSQL"
        }

        // Generate actor instantiation and exposure
        var actorSetup = ""
        for actor in actors {
            let actorVarName = actor.name.prefix(1).lowercased() + actor.name.dropFirst()
            let actorID = actor.name.lowercased().replacingOccurrences(of: "actor", with: "")

            actorSetup += """

                // \(actor.name)
                let \(actorVarName) = \(actor.name)(actorSystem: server.actorSystem)
                await server.expose(\(actorVarName), as: "\(actorID)")
                terminal.print("  âœ“ \(actor.name) exposed as '\(actorID)'", style: .dim)

            """
        }

        // State store setup
        var stateStoreSetup = ""
        if needsPostgreSQL {
            stateStoreSetup = """

                // PostgreSQL state store
                let stateStore: PostgreSQLStateStore?
                if let dbUrl = ProcessInfo.processInfo.environment["DATABASE_URL"] {
                    terminal.print("Connecting to PostgreSQL...", style: .dim)
                    stateStore = try await PostgreSQLStateStore(connectionString: dbUrl)
                    terminal.print("  âœ“ PostgreSQL connected", style: .success)
                } else {
                    terminal.print("âš ï¸  DATABASE_URL not set, running without state persistence", style: .warning)
                    stateStore = nil
                }

            """
        }

        return """
        \(imports)

        @main
        struct TrebucheAutoServer {
            static func main() async throws {
                let terminal = Terminal()
                let port = UInt16(ProcessInfo.processInfo.environment["PORT"] ?? "8080")!

                terminal.print("")
                terminal.print("ðŸš€ Trebuche Auto-Generated Server", style: .header)
                terminal.print("")
        \(stateStoreSetup)
                terminal.print("Starting server on port \\(port)...", style: .dim)

                let server = TrebuchetServer(transport: .webSocket(port: port))

                // Expose all discovered actors
        \(actorSetup)
                terminal.print("")
                terminal.print("âœ“ Server running on port \\(port)", style: .success)
                terminal.print("  WebSocket: ws://localhost:\\(port)", style: .dim)
                terminal.print("")

                try await server.run()
            }
        }

        // Terminal helper (inline to avoid dependency issues)
        struct Terminal {
            enum Style {
                case header, success, error, warning, info, dim
            }

            func print(_ message: String, style: Style = .info, terminator: String = "\\n") {
                let styled: String
                switch style {
                case .header:
                    styled = "\\u{001B}[1;36m\\(message)\\u{001B}[0m"  // Bold cyan
                case .success:
                    styled = "\\u{001B}[32m\\(message)\\u{001B}[0m"    // Green
                case .error:
                    styled = "\\u{001B}[31m\\(message)\\u{001B}[0m"    // Red
                case .warning:
                    styled = "\\u{001B}[33m\\(message)\\u{001B}[0m"    // Yellow
                case .info:
                    styled = message
                case .dim:
                    styled = "\\u{001B}[2m\\(message)\\u{001B}[0m"     // Dim
                }
                Swift.print(styled, terminator: terminator)
            }
        }

        """
    }

    private func generateREADME(projectName: String, actors: [ActorMetadata]) -> String {
        var actorsList = ""
        for actor in actors {
            actorsList += "- **\(actor.name)**\n"
            for method in actor.methods {
                actorsList += "  - `\(method.signature)`\n"
            }
        }

        return """
        # Trebuche Auto-Generated Server

        This server package was automatically generated by the `trebuche` CLI from your actors.

        ## Discovered Actors

        \(actorsList)

        ## Running Locally

        ```bash
        swift run
        ```

        The server will start on port 8080 by default.

        ## Deploying

        From the parent directory:

        ```bash
        trebuche deploy --provider fly
        # or
        trebuche deploy --provider aws
        ```

        ## Regenerating

        To regenerate this server after adding/modifying actors:

        ```bash
        trebuche generate server --force
        ```

        Or simply deploy (regenerates by default):

        ```bash
        trebuche deploy
        ```

        ## Manual Deployment

        You can also deploy this server manually:

        ### Fly.io

        ```bash
        fly launch
        fly deploy
        ```

        ### Docker

        ```bash
        docker build -t \(projectName.lowercased())-server .
        docker run -p 8080:8080 \(projectName.lowercased())-server
        ```

        ---

        *This file was auto-generated by trebuche CLI*

        """
    }
}
